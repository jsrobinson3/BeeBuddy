#!/bin/bash
# BeeBuddy pre-commit hook
# Runs linters, formatters, and safety checks on staged files before committing.
# Install: cp scripts/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
ERRORS=0

# Colors (disabled if not a terminal)
if [ -t 1 ]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  CYAN='\033[0;36m'
  NC='\033[0m'
else
  RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

info()  { echo -e "${CYAN}[pre-commit]${NC} $*"; }
pass()  { echo -e "${GREEN}  ✓${NC} $*"; }
warn()  { echo -e "${YELLOW}  ⚠${NC} $*"; }
fail()  { echo -e "${RED}  ✗${NC} $*"; ERRORS=$((ERRORS + 1)); }

# Get staged files (only added/modified, not deleted)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
  info "No staged files — skipping checks."
  exit 0
fi

# ── 1. Secrets & Credential Detection (gitleaks) ─────────────────────
info "Checking for secrets and credentials..."

# Find gitleaks: ~/.local/bin → PATH
GITLEAKS=""
if [ -x "$HOME/.local/bin/gitleaks" ]; then
  GITLEAKS="$HOME/.local/bin/gitleaks"
elif command -v gitleaks &>/dev/null; then
  GITLEAKS="gitleaks"
fi

if [ -n "$GITLEAKS" ]; then
  GITLEAKS_CONFIG=""
  if [ -f "$REPO_ROOT/.gitleaks.toml" ]; then
    GITLEAKS_CONFIG="--config=$REPO_ROOT/.gitleaks.toml"
  fi

  GITLEAKS_OUTPUT=$($GITLEAKS protect --staged --no-banner $GITLEAKS_CONFIG 2>&1) || GITLEAKS_EXIT=$?
  GITLEAKS_EXIT=${GITLEAKS_EXIT:-0}

  if [ "$GITLEAKS_EXIT" -ne 0 ]; then
    fail "Secrets detected by gitleaks:"
    echo "$GITLEAKS_OUTPUT" | head -30
    echo ""
  else
    pass "No secrets detected (gitleaks)"
  fi
else
  warn "gitleaks not found — skipping secret detection (install: https://github.com/gitleaks/gitleaks)"
fi

# ── 2. Forbidden File Check ───────────────────────────────────────────
info "Checking for forbidden files..."

FORBIDDEN_FOUND=0
for file in $STAGED_FILES; do
  case "$file" in
    .env|.env.local|.env.*.local)
      fail "Refusing to commit environment file: $file"
      FORBIDDEN_FOUND=1
      ;;
    *.pem|*.key|*.p12|*.pfx)
      fail "Refusing to commit private key/cert: $file"
      FORBIDDEN_FOUND=1
      ;;
    credentials.json|secrets.json)
      fail "Refusing to commit credentials file: $file"
      FORBIDDEN_FOUND=1
      ;;
  esac
done
[ $FORBIDDEN_FOUND -eq 0 ] && pass "No forbidden files"

# ── 3. Large File Check ──────────────────────────────────────────────
info "Checking for oversized files..."

MAX_FILE_SIZE=1048576  # 1 MB
LARGE_FOUND=0
for file in $STAGED_FILES; do
  [ -f "$REPO_ROOT/$file" ] || continue
  file_size=$(wc -c < "$REPO_ROOT/$file")
  if [ "$file_size" -gt "$MAX_FILE_SIZE" ]; then
    # Allow lock files
    case "$file" in
      *.lock|package-lock.json|uv.lock) continue ;;
    esac
    fail "$file is $(( file_size / 1024 ))KB (max 1024KB). Use Git LFS for large files."
    LARGE_FOUND=1
  fi
done
[ $LARGE_FOUND -eq 0 ] && pass "No oversized files"

# ── 4. Merge Conflict Markers ────────────────────────────────────────
info "Checking for merge conflict markers..."

CONFLICTS_FOUND=0
for file in $STAGED_FILES; do
  [ -f "$REPO_ROOT/$file" ] || continue
  case "$file" in
    *.lock|*.png|*.jpg|*.jpeg|*.gif|*.ico) continue ;;
  esac
  if grep -qE '^(<<<<<<<|=======|>>>>>>>)' "$REPO_ROOT/$file" 2>/dev/null; then
    fail "Merge conflict markers in $file"
    CONFLICTS_FOUND=1
  fi
done
[ $CONFLICTS_FOUND -eq 0 ] && pass "No merge conflict markers"

# ── 5. Python Linting (ruff) ─────────────────────────────────────────
PYTHON_FILES=$(echo "$STAGED_FILES" | grep '\.py$' || true)

if [ -n "$PYTHON_FILES" ]; then
  info "Linting Python files with ruff..."

  # Find ruff: project venv → api venv → global
  RUFF=""
  if [ -x "$REPO_ROOT/.venv/bin/ruff" ]; then
    RUFF="$REPO_ROOT/.venv/bin/ruff"
  elif [ -x "$REPO_ROOT/apps/api/.venv/bin/ruff" ]; then
    RUFF="$REPO_ROOT/apps/api/.venv/bin/ruff"
  elif command -v ruff &>/dev/null; then
    RUFF="ruff"
  fi

  if [ -n "$RUFF" ]; then
    # Lint check
    PY_PATHS=""
    for f in $PYTHON_FILES; do
      [ -f "$REPO_ROOT/$f" ] && PY_PATHS="$PY_PATHS $REPO_ROOT/$f"
    done

    if [ -n "$PY_PATHS" ]; then
      LINT_OUTPUT=$($RUFF check --config "$REPO_ROOT/apps/api/pyproject.toml" --no-fix $PY_PATHS 2>&1) || true
      if [ -n "$LINT_OUTPUT" ] && ! echo "$LINT_OUTPUT" | grep -q "All checks passed"; then
        fail "Ruff lint errors:"
        echo "$LINT_OUTPUT" | head -20
        echo ""
      else
        pass "Ruff lint passed"
      fi

      # Format check
      FORMAT_OUTPUT=$($RUFF format --config "$REPO_ROOT/apps/api/pyproject.toml" --check $PY_PATHS 2>&1) || true
      if [ $? -ne 0 ] && echo "$FORMAT_OUTPUT" | grep -q "would reformat"; then
        fail "Ruff format issues (run 'ruff format' to fix):"
        echo "$FORMAT_OUTPUT" | head -10
        echo ""
      else
        pass "Ruff format passed"
      fi
    fi
  else
    warn "ruff not found — skipping Python lint (install: pip install ruff)"
  fi
fi

# ── 6. TypeScript Type Checking ──────────────────────────────────────
TS_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ts|tsx)$' || true)

if [ -n "$TS_FILES" ]; then
  info "Type-checking TypeScript files..."

  # Only run tsc if mobile app files changed
  MOBILE_TS=$(echo "$TS_FILES" | grep '^apps/mobile/' || true)
  if [ -n "$MOBILE_TS" ]; then
    if [ -f "$REPO_ROOT/apps/mobile/node_modules/.bin/tsc" ]; then
      TSC_OUTPUT=$(cd "$REPO_ROOT/apps/mobile" && npx tsc --noEmit 2>&1) || true
      if [ $? -ne 0 ] && [ -n "$TSC_OUTPUT" ]; then
        fail "TypeScript errors in apps/mobile/:"
        echo "$TSC_OUTPUT" | head -20
        echo ""
      else
        pass "TypeScript type-check passed"
      fi
    else
      warn "tsc not found in apps/mobile — skipping type check"
    fi
  fi
fi

# ── 7. JSON / YAML Syntax Validation ─────────────────────────────────
JSON_FILES=$(echo "$STAGED_FILES" | grep -E '\.(json)$' || true)
YAML_FILES=$(echo "$STAGED_FILES" | grep -E '\.(ya?ml)$' || true)

if [ -n "$JSON_FILES" ] || [ -n "$YAML_FILES" ]; then
  info "Validating config file syntax..."

  SYNTAX_OK=1
  for file in $JSON_FILES; do
    [ -f "$REPO_ROOT/$file" ] || continue
    # Skip lock files
    case "$file" in
      package-lock.json|*.lock) continue ;;
    esac
    if ! python3 -c "import json; json.load(open('$REPO_ROOT/$file'))" 2>/dev/null; then
      fail "Invalid JSON syntax: $file"
      SYNTAX_OK=0
    fi
  done

  for file in $YAML_FILES; do
    [ -f "$REPO_ROOT/$file" ] || continue
    if python3 -c "import yaml; yaml.safe_load(open('$REPO_ROOT/$file'))" 2>/dev/null; then
      :
    elif python3 -c "
import sys
with open('$REPO_ROOT/$file') as f:
    content = f.read()
    # Basic YAML syntax check — detect obvious issues
    for i, line in enumerate(content.splitlines(), 1):
        stripped = line.lstrip()
        if stripped and stripped[0] == '\t':
            print(f'Tab indentation at line {i}', file=sys.stderr)
            sys.exit(1)
" 2>/dev/null; then
      :
    else
      warn "Could not validate YAML: $file (install PyYAML for full validation)"
    fi
  done

  [ $SYNTAX_OK -eq 1 ] && pass "Config file syntax OK"
fi

# ── 8. Dockerfile Best Practices ─────────────────────────────────────
DOCKER_FILES=$(echo "$STAGED_FILES" | grep -iE '(Dockerfile|\.dockerfile)$' || true)

if [ -n "$DOCKER_FILES" ]; then
  info "Checking Dockerfiles..."

  DOCKER_OK=1
  for file in $DOCKER_FILES; do
    [ -f "$REPO_ROOT/$file" ] || continue

    # Check for latest tag
    if grep -qE '^FROM\s+\S+:latest' "$REPO_ROOT/$file"; then
      warn "Dockerfile '$file' uses :latest tag — pin to a specific version"
    fi

    # Check for root user
    if ! grep -q '^USER' "$REPO_ROOT/$file"; then
      warn "Dockerfile '$file' doesn't set a non-root USER"
    fi
  done

  [ $DOCKER_OK -eq 1 ] && pass "Dockerfile checks passed"
fi

# ── Summary ───────────────────────────────────────────────────────────
echo ""
if [ $ERRORS -gt 0 ]; then
  echo -e "${RED}Pre-commit failed with $ERRORS error(s).${NC} Fix issues and try again."
  echo -e "To bypass (emergency only): ${YELLOW}git commit --no-verify${NC}"
  exit 1
else
  echo -e "${GREEN}All pre-commit checks passed.${NC}"
  exit 0
fi
